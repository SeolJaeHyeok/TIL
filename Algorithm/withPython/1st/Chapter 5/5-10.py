# 음료수 얼려 먹기
# sol
n, m = map(int, input().split())

graph = []
for _ in range(n):
    graph.append(list(map(int, input())))


# DFS로 특정한 노드를 방문한 뒤에 연결된 모든 노드들도 방문
def dfs(x, y):
    # 주어진 범위를 벗어나는 경우에는 즉시 종료
    if x <= -1 or x >= n or y <= -1 or y >= m:
        return False
    # 현재 노드를 아직 방문하지 않았다면
    if graph[x][y] == 0:
        # 해당 노드를 방문 처리
        graph[x][y] = 1
        # 상, 하, 좌, 우의 위치도 모두 재귀적으로 호출
        dfs(x - 1, y)
        dfs(x, y - 1)
        dfs(x + 1, y)
        dfs(x, y + 1)
        return True
    return False


# 모든 노드(위치)에 대하여 음료수 채우기
result = 0
for i in range(n):
    for j in range(m):
        # 현재 위치에서 DFS 수행
        if dfs(i, j):
            result += 1

print(result)

"""
풀이 해석
시작점에서 해당 값을 체크하고 해당 값이 0이라면 방문처리 해주고 상,하,좌,우를 재귀호출 한다.
상,하,좌,우 호출한 값이 0이라면 1로 바꿔주고 다시 한번 그 위치에서 상,하,좌,우를 재귀호출
위와 같은 과정을 주변의 모든 값이 1이 될 때까지 반복 
모든 값이 1이 된 후에 시작점에서부터 재귀호출된 모든 함수들이 스택에서 빠져나가고(False 리턴을 하면 해당 함수가 종료되므로 스택에서 제거)
if 문 안의 True 리턴(==시작점에서 만들 수 있는 가장 큰 크기의 아이스크림을 만듦)

반복문을 통해 모든 노드(위치)에 대해 음료수를 채우고(=모든 노드 순회해서 각각의 노드를 시작점으로 하는 dfs 호출) dfs 함수에서 리턴한 값이 True인 경우 카운팅
반복문을 통해 호출한 dfs 함수의 값이 True인 경우는 해당 시작점의 값이 0인 경우고 False인 경우는 해당 시작점의 값이 1인 경우

ex) 
(0,0)이 시작점이라고 했을 경우 해당 노드를 1로 바꾸고 상,하,좌,우를 방문 처리(해당 노드의 값이 0이라면 1로 바꿈)한다.
그렇게 주변의 모든 노드가 1이 됐으면 해당 시작점(0,0)에서의 dfs 함수가 끝나게 되고 다음 시작점(0,1)에서 위와 같이 반복해준다. 
각각의 모든 노드를 시작점으로 하여 dfs 함수를 통과 시켜보면
True를 리턴한 경우(시작점이 0이고 주변으로 뻗어가면서 주변의 0인 노드를 1로 만든 다음 상,하,좌,우가 모두 1이 아닐 때까지 왔을때)가 해당 시작점에서 만들 수 있는
아이스크림의 가장 큰 크기가 된다. 
"""