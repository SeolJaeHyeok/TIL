# 2022/08/19 - Review

### 1. 브라우저가 화면을 렌더링 하는 동작에 대해서 설명해보세요.

- HTML 파일을 파싱 후 DOM 트리 구축
- CSS 파일을 파싱 후 CSSOM 트리 구축
- Javascript 파일 (script 태그)를 만나면 Javascript를 실행 -> 다만 HTML 파일 중간에 script 태그가 있는 경우는 HTML 파싱을 중단하고 Javascript를 실행
- DOM 트리와 CSSOM 트리를 조합해서 Render 트리 구축 - Reflow
- Viewport를 기준으로 각 노드가 가지고 있는 위치를 설정 - Layout
- 위 과정에서 계산된 위치를 바탕으로 화면을 그린다. - Paint

---

### 2. CSR과 SSR의 차이와 각각의 장단점에 대해서 설명해보세요

**CSR**

한 번의 요청을 통해 HTML, CSS, Javascript 파일을 받아오고 사용자와의 상호작용에 따라  Javascript를 통해 동적으로 화면을 렌더링한다.

장점

- 서버에 단 한 번 요청을 하기 때문에 서버의 부하가 줄어들다.
- 사용자와의 상호 작용을 통해 동적으로 빠르게 화면을 렌더링 시키기 때문에 사용자 경험이 좋다.



단점

- 파일 크기가 커지게 되면 초기 로딩 시간이 길어질 수 있고 이는 곧 사용자 경험의 저하로 이어질 수 있다.
- 크롬을 제외한 다른 브라우저에서는 Javascript를 지원하지 않기 때문에 검색 엔진 봇이 크롤 하는 데에 문제가 있고 이로 인해 검색 엔진 최적화(SEO)에 어려움이 있다.

---

**SSR**

각각의 페이지 별로 서버에 요청을 해서 HTML, CSS, Javascript 파일을 받아와 화면을 렌더링한다.

장점

-  초기 로딩 속도가 빠르다
-  JS를 통해 동적으로 화면을 렌더링 하는 것이 아니기 때문에 검색 엔진 최적화에 용이하다.

단점

- 페이지를 요청할 때마다 새로고침을 하기 때문에 사용자 경험이 좋지 않을 수 있다.
- 서버에 많은 요청을 하기 때문에 서버에 부담이 크다.

---

### 3. www.google.com 을 주소창에 입력했을 때 발생하는 동작을 설명해보세요.

- URL을 웹 브라우저의 주소창에 입력한다.
- 웹 브라우저가 URL을 해석하고, 문법에 맞지 않으면 기본 검색엔진으로 검색한다.
- 문법에 맞으면 URL의 호스트 부분을 인코딩한다.
- HSTS(HTTP Strict Transport Security) 목록을 확인하고 있으면 HTTPS로, 없으면 HTTP로 요청한다.
- DNS(Domain Name Server) 조회
  - 브라우저/로컬 캐시 확인해서 도메인에 해당하는 IP가 있는지 확인한다.
  - 없으면 OS에게 DNS 서버에 요청하라고 지시한다.
  - DNS 서버는 해당 도메인에 해당하는 IP를 돌려준다.
- TCP 소켓을 열고 3-way handshake로 연결을 설정한다.
- HTTPS 요청이라면 TLS(Transport Layer Security) handshake 과정을 통해 세션키를 생성한다.
- 세션이 유지되는 동안 서버에게 요청하고 응답을 받는 과정을 반복한다.
  - 응답 상태코드에 따라 다르게 처리한다.
  - 응답을 디코딩(Decoding)하고 캐싱 가능하다면 캐싱한다.
- 웹브라우저는 응답받은 HTML/CSS/JS 및 이미지,폰트 등의 리소스를 사용하여 렌더링 한다.
- 서버와의 세션이 종료되면 4-way handshake로 연결을 종료한다.

 ---

### 4. CSS 속성 중에 visibility: hidden과 display: none의 차이점을 설명해보세요.

`visibility:hidden` - 해당 엘리먼트를 렌더링을 하고 난 후 화면에서 보이지 않게 만드는 것. 단, width와 height를 설정한 경우 공간은 차지한다.

`display: none` - 해당 엘리먼트를 애초에 렌더링 하지 않는 속성. 어떠한 공간도 차지하지 않는다.

---

### 5. 마진 겹침 현상에 대해서 설명해보세요.

마진 겹침 현상은 블록 레벨 엘리먼트에 한해서 발생하는 현상으로 좌우 방향이 아닌 오로지 수직 방향으로 적용된다.

2개의 마진이 겹칠 때 더 큰 마진으로 덮어 씌우는 방식이며 마진이 음수인 경우 더하는 방식을 취한다.

#### **마진겹침이 발생하는 경우**

1. 인접한 엘리먼트
2. 부모와 처음/마지막 자식 사이
   - 부모의 마진과 처음 또는 마지막 자식의 마진이 같은 경우 완전히 겹쳐서 나타나게 되는데 이를 해결하기 위해서는 **부모에 inline 컨텐츠, border, padding** 을 줘서 경계를 구분시키면 된다.
3. 빈 엘리먼트
   - 높이가 없는 빈 엘리먼트가 인접했을 때도 마진 겹침 현상이 발생한다. 이를 해결하기 위해서는 **빈 엘리먼트에 height, min-height, padding, border나 inline 컨텐츠** 를 줘서 경계를 구분시키면 된다.

---

### 6-1. 알고 있는 display 속성에 대해서 말해보세요.

inline , flex , block, none, inline-block, grid

### 6-2. inline과 inline-block의 차이는 무엇인가요?

**inline**

- inline 속성을 가진 태그는 가로폭을 전부 차지 하지 않고 상위 태그 옆으로 붙는 특징이 있다.

- width와 height값을 지정해도 크기는 변하지 않는다.

**block**

- block 속성을 가진 태그는 가로폭을 전부 차지하며 width, height값을 가질 수 있다.

**inline-block**

- inline-block는 이러한 inline 속성과 block속성의 특징을 모두 가지고 있는 속성
- 가로폭을 전부 차지하지 않고, width와 height 값을 가질 수 있다.

---

### 7. CORS에 대해서 설명해보세요.

다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 **cross-origin HTTP 요청** 에 의해 요청된다.

하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한하는데 이것을 `Same-Origin-Policy(동일 근원 정책)`이라고 한다. 다시 말해, 요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜, 호스트명, 포트가 같아야 함을 의미한다

여기서 `CORS`는 타 도메인 간에 자원을 공유할 수 있게 해주는 것이다. `Cross-Origin Resource Sharing` 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 **출처 집합**을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로써 동작한다.



**클라이언트에서 CORS 해결하기**

1. 웹 브라우저 실행 옵션이나 플러그인을 통한 동일 출처 정책 회피하기
   - 동일 출처 정책은 브라우저에서 임의로 하는 것이기 때문에 브라우저에서 동일 출처 정책을 사용하지 않으며 된다.
2. jsonp 방식으로 json 데이터 가져오기
   - 자바스크립트 파일이나 css 파일은 동일 출처 정책에 영향을 받지 않고 가져올 수 있다.
   - 이를 이용해서 자바스크립트 파일을 가져와서 이를 json 형식으로 파싱해서 데이터를 사용할 수 있다.

[참고](https://bohyeon-n.github.io/deploy/web/cors.html)

---

### 8. 화살표 함수와 `function` 키워드를 사용하여 선언한 함수의 차이점에 대해 설명해보세요.

1. 기존의 함수보다 간략하게 함수를 표현할 수 있다.

2. 화살표 함수는 인스턴스를 생성할 수 없는 `non-constructor`이다.

   ```javascript
   const Foo = () => {};
   // 화살표 함수는 생성자 함수로 호출할 수 없다.
   new Foo(); // TypeError: Foo is not a constructor
   ```

3. 화살표 함수는 함수 자체의 `this`를 바인딩하지 않는다.

   - 화살표 함수 내부에서 `this` 에 접근하게 되면 `this` 가 가리키는 곳은 화살표 함수를 선언한 스코프(상위 스코프)의 `this`를 참조하게 된다.

---

### 9. 자바스크립트 엔진이 비동기를 처리하는 과정에 대해서 설명해보세요

#### 1. 비동기 처리를 이해하기 위해 알아야 하는 용어

**1) 논 블로킹**

자바스크립트 엔진은 기본적으로 싱글 쓰레드로 동작하기 때문에 비동기 동작의 경우 **Webapi(브라우저)**에게 비동기 동작(ex: http 요청)을 위임함으로써 다른 동작을 실행할 수 있다.

**2) 콜 스택**

자바스크립트가 코드를 실행할 때 생성하는 실행 컨텍스트를 저장하는 자료구조

1. 자바스크립트 엔진은 함수를 호출하면 이를 콜 스택에 추가한 후 함수를 실행한다.
2. 함수에 의해 호출 되는 모든 함수(내부 함수)는 콜 스택에 추가되고 해당 위치에서 실행된다.
3. 함수의 실행이 종료되면 콜스택에서 제거한 후 중단된 시점부터 다시 실행한다.
4. 스택으로 할당된 공간보다 많은 공간을 차지하면 stack overflow가 발생한다.

**3) 태스크 큐** 

태스크 큐는 `setTimeout` 이나 `setInterval`과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역

**4) 이벤트 루프**

이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다.

***만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.***



#### 2. 자바스크립트 엔진이 비동기를 처리하는 방식

1. 코드를 실행한 후 자바스크립트 엔진이 비동기 작업을 만나게 되면 비동기 작업은 Webapi에 위임(태스크 큐에 push)되어 대기하게 된다.
2. 만약 콜 스택이 비어 있는 것을 이벤트 루프가 확인을 하게 되면, 다시 말해 전역 코드 및 명시적으로 호출된 함수가 모두 종료하면 
   이벤트 루프가 태스크 큐에 존재하는 콜백 함수를 콜 스택에 넘겨주고 콜 스택에 존재하는 콜백 함수를 실행한 후 콜 스택에서 제거한다.

---

### 10. call by value call by reference

변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시값이 복사되어 전달됩니다. 이를 값에 의한 전달이라고 합니다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달되고 이를 참조에 의한 전달이라 합니다.

---

### 11. promise의 정의와 어떻게 생성할 수 있나요?

promise는 es6에 새로 도입된 비동기 처리를 위한 패턴입니다. 프로미스는 전통적인 콜백 패턴의 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있습니다. promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스를 생성합니다. promise생성자 함수는 비동기 처리를 수행할 콜백 함수를 인자로 받는데 이 콜백함수는 resolve와 reject를 함수 인자로 전달받습니다.

---

### 12. 디바운쓰와 스로틀의 차이가 무엇인가요?

디바운스는 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 헨들러를 호출하지 않다가 일정시간이 경과한 후에 이벤트를 한번만 호출되도록 합니다. 즉 디바운스는 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한번만 이벤트 핸들러가 호출되도록 합니다.

스로틀은 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트가 최대 한번만 호출되도록 합니다. 즉, 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호츨 주기를 만듭니다.

---

### 13. babel이란 무엇인가

Babel은 자바스크립트 컴파일러로서, 최신의 자바스크립트 코드를 이전 단계의 자바스크립트 코드로 변환 가능하게 해주는 트랜스파일러입니다. 바벨을 사용하여 최신 문법으로 자유롭게 코딩하면, 그것과 웹 브라우저의 호환을 Babel이 책임져 줍니다.

---

### 14. 폴리필이란 무엇인가요?

바벨은 ES6 이후의 문법들이 동작하지 않는 브라우저에서도 동작할 수 있도록 ES6 이전의 문법들로 트랜스파일링 해주는 역할을 합니다. 하지만 ES6의 Promise, Map, Set과 같은 개념들은 이전에 존재하지 않았기 때문에 트랜스파일링을 해줄 수가 없는데 이때, 위와 같은 개념들과 동일하게 동작할 수 있도록 메서드나 기능을 주입해주는 역할을 하는 것이 폴리필입니다.

---

### 15. set과 map의 차이

set은 배열과 비슷하고 map은 객체와 비슷한 자료구조입니다.

set과 배열이 다른점은 중복된 데이터가 저장되지 않는다는 것, 순서를 보장하지 않는다는 것 index를 이용해 요소에 접근할 수 없다는 점이 있습니다.

map 과 객체의 차이는 객체는 string이나 심볼 타입만 키로 지정이 가능하고 map은 객체를 포함한 모든 값을 키로 이용할 수 있습니다. 객체는 이터러블하지 않지만 map은 이터러블합니다.

---

### 16. **프로토타입이 무엇인가요?**

자바스크립트의 모든 객체는 프로토타입(prototype)이라는 객체를 가지고 있습니다.모든 객체는 그들의 프로토타입으로부터 프로퍼티와 메소드를 상속받습니다. 이처럼 자바스크립트의 모든 객체는 최소한 하나 이상의 다른 객체로부터 상속을 받으며, 이때 상속되는 정보를 제공하는 객체를 프로토타입(prototype)이라고 합니다.

---

### 17. DNS 란 무엇인가?

네트워크상의 모든 컴퓨터는 숫자를 이용하여 서로를 찾고 통신합니다. 이러한 숫자를 `IP 주소`라고 하며 사람이 기억하기에는 복잡하여 기억하기가 쉽지 않습니다. 그래서 IP주소를 사람이 기억하기 쉬운 언어체계로 변환해주는 역할을 해주는 시스템입니다.

---

### 18. HTTP와 HTTPS의 차이점에 대해 설명해주세요

HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜 입니다. HTTPS는 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 공개키 암호화를 지원합니다. HTTPS는 기관으로부터 검증된 사이트만 사용이 허가되기 때문에 내가 접속한 사이트가 상대적으로 안전한 주소를 가졌음을 증명하는 것이기도 합니다.

---

### 19. Props drilling은 무엇이고 어떻게 해결할 수 있나요?

- 답변

  > props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정입니다. props 전달이 많은 컴포넌트를 거칠수록 해당 prop을 추적하기 힘들고 유지보수가 어려워집니다. 또한 props 전달과정에서 불필요한 리렌더링이 일어나 성능상의 문제가 생깁니다.

  > `Redux`, `MobX`, `Recoil` 등 전역 상태관리 라이브러리를 이용해 해결할 수 있습니다.

  https://slog.website/post/13

---

### 20. 이벤트 위임에 대해 설명하고 사용예시를 들어주세요. *❓

- 답변

  > 하나의 이벤트 핸들러만을 요소의 공통 조상에 할당해 여러 요소를 다루는 이벤트 핸들링 패턴입니다. 이벤트 ❓캡처링 과 버블링을 활용합니다.

  > 쇼핑몰 웹사이트에서 장바구니의 상품 삭제를 구현할 때 사용할 수 있습니다. 장바구니 목록 컨테이너에 상품을 삭제하는 onClick핸들러를 할당하여 각각의 상품을 삭제할 수 있습니다.

  https://ko.javascript.info/event-delegation#tasks

---

### 21. 아이콘을 PNG가 아닌 SVG로 표현할 때 얻는 이점은 무엇인가요?

- 답변

  > SVG는 Scalable Vector Graphics 라는 이름에서 알 수 있듯이, 벡터 그래픽입니다.

  1. 비트맵 이미지 형식인 PNG와 달리 모든 사이즈에서 손실이나 품질 저하 없이 렌더링이 가능합니다.
  2. 단일 파일 또는 <svg> 코드 블록으로 반응형 아이콘을 구현할 수 있습니다.
  3. HTML에 직접 코드 블록을 삽입할 경우, 이미지 다운로드 요청없이 HTML과 함께 로드됩니다. https://web.dev/learn/design/icons/

  > 

---

### 22. 선언형 프로그래밍은 무엇이며 React에서는 어떻게 사용하고 있나요?

- 답변

  > 선언형 프로그래밍은 원하는 결과를 명시하고, 그 결과를 얻기 위한 내부의 로직은 추상화하는 프로그래밍 방식입니다.

  > React는 JSX 문법을 통해 UI가 어떻게 생겨야하는지 설계할 수 있습니다. 선언형 뷰를 사용하는 덕분에 코드를 예측 가능하고 디버그하기 쉽습니다.

  https://velog.io/@kairase024/리액트와-선언형-프로그래밍Declarative-Programming

---

### 23. 이벤트 캡처링 / 버블링 을 설명해보세요.

- 답변

  > 이벤트 버블링은 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 DOM트리구조를 따라서 상위 요소들로 전파되는 특성입니다. 버블링이 되지 않는 이벤트도 있는데, 이는 event 객체의 읽기 전용 속성인 bubbles의 값으로 확인 할 수 있습니다. 예시로 focus, blur 이벤트가 있습니다. 버블링을 중단하기 위해 event객체의 stopPropagation() 메서드를 사용할 수 있습니다.

  > 이벤트 캡처링은 최상위 조상에서 타깃 요소까지 이벤트가 하위 요소로 전파되는 특성입니다.

  https://ko.javascript.info/bubbling-and-capturing

---

### 24. CSS 명시도를 설명해보세요.

- 답변

  > 우선순위는

  1. 인라인 스타일
  2. 아이디 선택자의 수
  3. 클래스, 속성, 가상 클래스 선택자의 수
  4. 태그, 가상 요소 선택자의 수

  > 

  > 같은 우선순위의 경우 나중에 선언한 규칙이 우선 적용됩니다.

  > 예외로 !important 는 다른 스타일 선언보다 우선합니다.

  https://developer.mozilla.org/ko/docs/Web/CSS/Specificity

  https://specifishity.com/

---

### 25. 범용적인 웹사이트를 만들기 위해 필요한 개념들을 설명해주세요.

- 답변

  - 크로스 브라우징

    > 가능한 한 많은 브라우저에서 웹페이지가 작동하도록 한다.

  - 반응형 웹 디자인

    > 데스크탑, 모바일, 태블릿 등 다양한 기기에 대응할 수 있도록 기능과 레이아웃을 유연하게 만든다.

  - 성능

    > 오래된 브라우저, 저성능 기기나 느린 인터넷 환경에서도 사용자가 좌절하지 않도록, 페이지 로드를 가능한 빠르게 한다.

  - 접근성

    > 개인의 신체적, 인지적 능력 및 웹에 접근하는 방법과 관계없이 가능한 한 접근할 수 있도록한다.

  - 국제화(I18N)

    > 다양한 문화권의 사람들을 아우르는 콘텐츠를 개발한다. 언어를 읽는 방향, 날짜 표기법 등을 현지화한다.

  https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/The_web_and_web_standards

---

### 26. 디바운싱 / 스로틀링 는 무엇이고 언제 사용하나요?

- 답변

  > 두 방법 모두 **“DOM 이벤트를 기반으로 실행하는 자바스크립트에서 성능상의 이유로 이벤트(event)를 제어(제한)”** 하는 방법입니다.

  > 먼저 **`디바운싱`**은 **“연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것”** 입니다. 대표적으로 Ajax 요청이 있는 자동 완성 검색을 구현할 때 input이벤트를 제어합니다.

  > `스로틀링` 은 **“마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것”**입니다. 예시로는 무한 스크롤을 scroll 이벤트 기반으로 구현할 때 적용됩니다.

  https://www.zerocho.com/category/JavaScript/post/59a8e9cb15ac0000182794fa

---

### 27. `React` Props Drilling이란 무엇인가요?

Props Drilling이란 React의 **상위 컴포넌트에서 하위 컴포넌트로 전달하는 props를 너무 깊게 전달**하여 해당 props가 필요 없는 컴포넌트들까지 props를 받게 되어 **가독성이 떨어지고, props 추적이 어려워지는 문제**입니다.

**꼬리질문**

- Props Drilling을 해결하기 위한 방법으로는 어떤 것이 있을까요?

  렌더링 될 컴포넌트를 **불필요하게 여러 컴포넌트로 나누지 않아야 합니다**. 한 컴포넌트에서 관리할 수 있는 상태들을 불필요하게 props로 전달하여야 하기 때문입니다.

  가능한 **관련성이 높은 곳에 state 를 위치** 시켜야합니다. 즉, 해당 데이터를 필요로 하는 최소 공통 부모 컴포넌트에서 관리를 해야 최소한의 props를 전달할 수 있기 때문에 가장 효율적입니다.

  Context API나 Redux 등의 외부 **상태관리 라이브러리**를 사용해서도 드릴링을 피할 수 있습니다. 이는 전역적으로 상태를 관리할 수 있게 하여 상태의 변경사항을 보다 쉽게 추적할 수 있게 합니다.

---

### 28. `JavaScript` 이벤트루프 과정에 대해 설명해주세요

이벤트 루프란 Callback Queue에서 콜백 함수를 하나씩 꺼내서 동작시키는 Loop를 말합니다.

이벤트루프를 설명하기 위해 먼저 자바스크립트 엔진의 구성요소를 말씀드리겠습니다. **자바스크립트 엔진은** 참조타입 데이터가 저장되는 **Heap**, 원시타입 데이터가 저장되는 **Call Stack**,  DOM 조작, setTimeout, 네트워크 요청과 응답 등의 브라우저 고유 기능을 수행하는 **WebAPI,** WebAPI 로부터 전달받은 콜백 함수 저장하는 **Task Queue**로 구성됩니다. Task Queue는 Promise Callback같은 함수들이 저장되는 **Microtask Queue**와, setTimeout같은 함수들이 저장되는 **Macrotask Queue**로 구성되어 있습니다.

전체적인 과정을 예를 들어 설명드리겠습니다. 자바스크립트 엔진이 파일을 읽다가 함수를 만나면 해당 함수를 실행하기 위해 함수를 Call Stack에 올립니다. 만약 setTimeout이나 Promise callback같은 함수를 만나면 해당 비동기 작업을 위한 콜백함수를 Web API를 거쳐서 Task Queue로 보냅니다. 그 후, Call Stack이 비어있으면 Task Queue에 있는 작업을  Call Stack으로 보냅니다. 이 과정을 이벤트 루프라고 합니다.

---

### 29. `프로그래밍`선언적 프로그래밍이란 무엇인가요?

선언적 프로그래밍이란 원하는 것을 얻기 위한 과정을 하나하나 기술하기 보다는 **원하는 것이 어떤 것인지 기술**하는 것에 초점을 맞춘 프로그래밍 패러다임입니다.

**꼬리질문**

- 선언적인 코드는 어떤 장점이 있을까요?

  선언적인 코드는 **코드의 양을 줄일 수 있기 때문에 가독성을 높입니다**.

  또한, 코드 내에서 어떠한 상태를 변경시키지 않기 때문에 코드 내에서 사용하는 변수들을 최소화하고, 코드를 캡슐화하여 코드 내부에서 사용하는 변수의 외부 접근을 막을 수 있습니다.

- 선언적으로 코드의 예시와 어떤 점이 좋아졌는지 설명해주세요.

  ```jsx
  //명령형 코드
  function double (arr) {
    let results = []
    for (let i = 0; i < arr.length; i++){
      results.push(arr[i] * 2)
    }
    return results
  }
  
  //선언형 코드
  function double (arr) {
    return arr.map((item) => item * 2)
  }
  ```

  두 함수 모두 배열 안에 있는 요소들의 값을 2배로 만들어서 출력하는 함수입니다.

  **명령적인 코드**는 함수 내에서 result라는 변수를 만들어 해당 변수를 계속 변경하는 일종의 **상태를 변경**시키고, **단계적으로 원하는 값을 얻기 위한 절차를 코드로 작성**합니다. 이러한 이유로 **가독성이 떨어집니다**.

  이 코드를 코드를 **선언적**으로 작성하면 어떠한 **상태를 변경시키지 않고**, 일련의 과정 없이 **원하는 값을 바로 반환하기** 때문에 **가독성이 더 좋아집니다**.

---

### 30. `프로그래밍` 소프트웨어 개발에서 “추상화”라는 개념에 대해 설명해주세요

소프트웨어 개발에서 추상화란 어떠한 개념에서 공통되는 특성이나 속성을 추출하여 표현하는 방식, 즉, **구체적인 정보에서 핵심적인 정보만 뽑아 목적에 맞게 맞게 단순화하여 표현하는 방식**입니다.

**꼬리질문**

- 코드를 추상화하면 어떤 장점이 있나요?

  코드 **중복 방지 및 재사용성 향상**시키고, 이로인해 **유지보수 시간이 줄어듭니다**. 또한, 중요한 세부 정보만 사용자에게 제공하므로 프로그램의 **보안** 향상에 도움이 됩니다.

---

### 31. `JavaScript` 클로저는 무엇인가요? 원리와 왜 사용하는지 설명해 주세요

클로저는 함수와 그 함수가 선언됐을 때의 **렉시컬 환경(Lexical environment)**과의 조합입니다.

즉, **클로저 함수는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 스코프 밖에서 호출되어도 그 스코프에 접근할 수 있는 함수**를 말합니다.

자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 내부함수가 외부 함수의 렉시컬 환경을 상위 스코프로 저장하고 있으므로 외부 함수의 렉시컬 환경에 대한 참조가 끊어지지 않기 때문에 **외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있습니다.**

클로저는 상태가 **의도치 않게 변경되지 않도록** **상태를 안전하게 은닉**하고 **특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용합니다.**

---

### 32. 쿠키와 세션의 차이

가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다.

- 쿠키의 경우 클라이언트 측에서 사용자의 정보를 저장하는 것 - `"아이디와 비밀번호를 저장하시겠습니까?"`, `팝업창 다시 보지 않기 `

- 세션의 경우 웹 서버 측에서 사용자의 정보를 저장하는 것 - `화면이 이동해도 로그인 상태 유지`
- 다시 말해, 쿠키는 서버 자원을 전혀 사용하지 않고 세셔은 서버 자원을 사용한다. 그렇기 때문에 보안적인 측면에서 세션이 더 유리하다.