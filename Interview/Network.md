## 네트워크

### - HTTP

[참고](https://github.com/baeharam/Must-Know-About-Frontend/tree/main/Notes/network)

클라이언트-서버 모델을 따르는 프로토콜로 TCP/IP 위에서 수행되며 well-known 포트인 80번 포트를 사용한다. 

특징으로는 클라이언트가 요청한 정보를 응답받으면 연결을 끊어버리는 비-연결지향(Connectionless)적인 특징을 가지고 있다. 이로 인해 서버에 부담을 줄여줄 수 있지만 많은 HTTP 요청들이 발생하기 때문에 요청마다 연결을 해야하는 오버헤드 비용이 발생할 수 있다. 

또다른 특징으로는 무상태성(Stateless)이 있다. 이는 각각의 요청이 독립적으로 여겨지는 특성으로 서버가 클라이언트의 상태를 유지하지 않는다. 즉, 각 클라이언트에 맞게 리소스를 응답하는 것이 불가능하다. 이를 해결하기 위해 쿠키나 세션, Oauth나 JWT 등이 이용된다. 

**Method**

- GET: 서버에게 조회할 리소스를 요청 (READ, 조회)
- POST: 서버에게 본문(body)에 생성할 데이터를 삽입하여 전송 (CREATE, 생성)
- PUT: 서버에게 본문에 수정할 데이터를 삽입하여 전송 (UPDATE, 수정)
- DELETE: 서버에게 삭제할 리소스를 요청 (DELETE, 삭제)
- PATCH: PUT과 비슷하지만 일부만 수정한다는 점에서 다름

**응답 상태 코드**

서버가 클라이언트에게 요청을 받으면 응답상태에 따라 다른 상태 코드를 클라이언트에게 돌려준다.

- 1xx(요청에 대한 정보) - 요청을 받았으면 작업을 계속
- 2xx(성공) - 요청을 성공적으로 수행
  - 200(요청 성공), 201(새 리소스 작성), 202(요청 접수, 아직 처리 x)
- 3xx(리다이렉션) - 클라이언트가 요청을 마치기 위해 추가적인 동작을 수행해야 함
  - 300(여러 개의 응답 선택해야 함), 301(영구 이동, 요청한 페이지가 영구적으로 이동), 302(임시 이동, 현재 응답이 다른 페이지지만 임시적임)
- 4xx(클라이언트 오류) - 클라이언트에 오류가 있음
  - 401(권한 없음), 403(금지됨, 리소스에 대한 권한이 없음), 404(찾을 수 없음)
- 5xx(서버 오류) - 서버에 오류가 있음
  - 500(내부 서버 오류), 501(요청 수행 기능 없음, 메서드 수행 불가), 503(서비스 사용 불가)

----

### - HTTPS

[참고](https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/network/https.md)

 **기존의 HTTP를 암호화한 프로토콜** 로 보안이 강화된 프로토콜이다.

----

### - HTTP/1.1과 HTTP/2.0의 차이

[참고](https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/network/http1.1-2.md)

**HTTP/1.1의 문제점**

- HTTP 요청을 할 때는 응답이 오고난 후에 다음 요청을 할 수 있는데 HTTP/1.1부터는 파이프라이닝 기법을 통해 여러 개의 요청을 연속적으로 할 수 있게 됐다. 하지만 이 또한 처음의 요청에 대한 응답이 오래 걸리는 경우 다음 응답까지의 시간이 오래 걸리는 문제가 발생했다. 이러한 문제는 Head Of Line Blocking이라고 한다.
- 매 요청마다 요청헤더에 메타 정보를 넣어서 보냈는데 정보가 많아져 헤더가 무거워지고 쿠키 같은 경우는 매번 보내기 때문에 중복이 많아지는 문제가 있다.

**HTTP/2의 개선방법**

- 멀티플렉싱과 스트리밍
  - HTTP 요청 데이터는 헤더와 본문으로 구성되는데 이를 각각 **프레임**이라는 단위로 저장하고 **스트림**이라는 연결 단위를 통해 헤더 프레임 혹은 본문 프레임을 보내도록 방식을 바꿨다. 이로 인해 HTTP/1.1의 문제점이었던 Head Of Line Blocking을 해결할 수 있었다.
- 서버 푸시
  - 브라우저가 요청하지 않으면 서버는 리소스를 보내주지 않는 것이 일반적인데 요청한 HTML 문서에 리소스가 있다면 서버가 브라우저에게 푸시하는 방법으로 브라우저의 요청을 최소화 시킨다.
- 헤더 압축
  - 헤더 테이블을 사용하여 이전 헤더 정보를 유지하고 헤더를 압축해서 전송하여 중복과 크기를 줄인다.

----

### - REST API

[참고](https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/network/rest-api.md)

**REST** -  자원을 주고받는 **웹 상에서의 통신 체계에 있어서 범용적인 스타일을 규정한 아키텍쳐** 라고 할 수 있다.

**REST API** - REST 원칙을 적용하여 서비스 API를 설계한 것을 말하며 대부분의 서비스가 REST API를 제공한다.

**REST의 특징**

- 균등한 인터페이스 - 플랫폼이나 언어의 제약을 받지 않음. REST API를 정의할 때는 주로 JSON 방식을 많이 사용
- 무상태성 - 클라이언트의 상태를 고려하지 않음. 클라이언트의 상태를 고려하지 않기 때문에 구현이 간결해짐.
- 캐싱 가능 - HTTP 표준을 기반으로 만들어졌기 때문에 HTTP의 특징인 캐싱을 사용할 수 있음. 캐싱을 사용하면 네트워크 응답시간 뿐만 아니라 서버에 API 요청을 하지 않기 때문에 부담이 덜하다는 장점이 있음.
- 자체 표현성 - REST API의 자원명시 규칙 및 메소드는 그 자체로 의미를 지니기 때문에 어떠한 요청에 있어서 그 요청 자체로 어떤 것을 표현하는지 알아보기 쉬움.
- 클라이언트-서버 구조 - REST 서버가 API를 제공하는 방식이기 때문에 클라이언트와 서버 간의 의존성이 낮아지고 이는 클라이언트와 서버가 최대한 독립적으로 개발할 수 있게끔 도와줌.
- 계층형 구조 - 클라리언트는 계층형 구조가 불가능하지만 REST 서버의 경우 보안/로드 밸런싱/암호화 등으로 계층화 할 수 있고 proxy나 게이트웨이처럼 중간 매체를 사용할 수도 있음.

**REST 핵심**

- URI는 리소스를 표현해야 한다.

  - 리소스명은 동사가 아닌 명사로 해야 한다.

    > /students/1

  - 리소스는 Collection과 Document로 표현할 수 있다.

- 그 리소스에 대한 행위는 HTTP의 메서드로 표현해야 한다.

  - GET은 리소스를 조회한다.

    > GET /students

  - POST는 리소스를 생성한다.

    > POST /students

  - PUT은 리소스를 업데이트한다.

    > PUT /students/1

  - DELETE는 리소스를 삭제한다.

    > DELETE /students/1

**HTTP 상태 코드**

요청에 대한 응답 코드를 잘 돌려주는 것이 잘 설계된 REST API이다.

- **2xx** : 성공 관련 (200 Ok, 201 Created)
- **3xx** : 리다이렉션 관련 (304 Not Modified)
- **4xx** : 클라이언트 에러 관련 (400 Bad Request, 401 Unauthorized)
- **5xx** : 서버 에러 관련 (500 Internal Server Error)

----

### - Cookie vs Session

[참고](https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/network/cookie-session.md)



----

### - URL을 입력하면 벌어지는 일

[참고](https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/network/type-url-process.md)

