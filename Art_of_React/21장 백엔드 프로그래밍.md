지금까지 리액트의 기본 개념을 대부분 다뤄 보았다. 웹 애플리케이션을 만들 때는 리액트 같은 프런트엔드 기술만으로 필요한 기능을 구현할 수 없는 경우가 흔하다. 데이터를 여러 사람과 공유하려면 저장할 공간이 필요하기 때문이다.

## 21.1 소개

#### 21.1.1 백엔드

서버를 만들어 데이터를 여러 사람과 공유할 때 데이터를 무작정 담지 않는다. 데이터를 담을 때는 여러 가지 규칙이 필요하다.

예를 들어 특정 데이터를 등록할 때 사용자 인증 정보가 필요할 수도 있고, 등록할 데이터를 어떻게 검증할지, 데이터의 종류가 다양하다면 어떻게 구분할지 등을 고려해야 한다. 

데이터를 조회할 때도 마찬가지다. 어떤 종류의 데이터를 몇 개씩 보여 줄지, 그리고 또 어떻게 보여 줄지 등에 관한 로직을 만드는 것을 서버 프로그래밍 또는 백엔드 프로그래밍이라고 한다.

백엔드 프로그래밍은 여러 언어로 작성할 수 있으나 여기서는 자바스크립트로 서버를 구현할 수 있는 Node.js를 사용해보도록 하자.

#### 21.1.2 Node.js

처음에는 자바스크립트를 웹 브라우저에서만 사용했다. 시간이 지나며 자바스크립트는 계속해서 발전했고 구글이 크롬을 소개하면서 V8이라는 자바스크립트 엔진도 공개했다. 이 자바스크립트 엔진을 기반으로 웹 브라우저뿐만 아니라 서버에서도 자바스크립트를 사용할 수 있는 런타임을 개발 했는데, 이게 바로 Node.js다.

#### 21.1.3 Koa

Node.js 환경에서 웹 서버를 구축할 때는 보통 Express, Hapi, Koa 등의 웹 프레임워크를 사용한다. 20장에서 SSR 서버를 구현할 때 Express를 사용했는데 21장에서는 Koa라는 프레임 워크를 사용해보도록 하자.

Koa는 Express의 기존 개발 팀이 개발한 프레임워크다. 

Express는 미들웨어, 라우팅, 템플릿, 파일 호스팅 등과 같은 다양한 기능이 자체적으로 내장되어 있는 반면, Koa는 미들웨어 기능만 갖추고 있으며 나머지는 다른 라이브러리를 적용하여 사용한다. 즉, Koa는 우리가 필요한 기능들만 붙여서 서버를 만들 수 있기 때문에 Express보다 훨씬 가볍다.

추가로 Koa는 async/await 문법을 정식으로 지원하기 때문에 비동기 작업을 더 편하게 관리할 수 있다.

이번 Node.js 기초 실습은 다음 흐름으로 진행된다.

> 작업 환경 준비  → Koa 서버 띄우기 → 미들웨어 알아보기 → koa-router를 통한 백엔드 라우팅 → 라우트 모듈화하기

## 21.2 작업 환경 준비

#### 21.2.1 Node 설치 확인

Node.js 개발을 하기 위해서는 당연히 Node.js 런타임이 설치되어 있어야 한다. 이미 1장에서 설치했기 때문에 제대로 설치되어 있는지 아래 명령어로 확인만 해보자.

` node --version`

<img src="./images/21_01.png" />

#### 21.2.2 프로젝트 생성

이번에 만들 백엔드 프로젝트는 이 책에서 다루는 마지막 프로젝트인 블로그 서비스와 연돌할 서버다. Blog 디렉터리를 만들고, 그 내부에 blog-backend 디렉터리를 만들자. 해당 디렉터리에서 `yarn init -y` 명령어를 실행해 패키지 정보를 만들어 준다.

위 작업을 다 하면 디렉터리에 package.json 파일이 생성된다. 다음 명령어를 실행하여 해당 파일이 잘 만들어졌는지 확인해 보자.

<img src="./images/21_02.png" />

이제 우리에게 필요한 Koa 웹 프레임워크를 설치해 보자.

`$ yarn add koa`

설치한 뒤 다시 한 번 package.json을 열어 보면 아래와 같이 koa가 dependencies에 추가 되어 있는 것을 확인할 수 있다.

<img src="./images/21_03.png" />

#### 21.2.3 ESLint 와 Prettier 설정

서버 파일을 작성하기 전 ESLint와 Prettier를 프로젝트에 적용하자. 이는 자바스크립트 문법을 검사하고 깔끔한 코드를 작성하기 위해서다.

두 기능을 VSCode에서 사용하려면 VSCode 마켓에서 Prettier-Code formatter와 ESLint 확장 프로그램을 설치해 둔 상태여야 한다. 

먼저 ESLint를 설치한다.

`$ yarn add --dev eslint`

`$ yarn run aslant --init`

> ❗️ yarn add 명령어를 사용할 때 --dev는 개발용 의존 모듈로 설치한다는 의미다. 이렇게 설치하면 package.json에서 devDependencies 쪽에 모듈의 버전 정보가 입력된다.

설치를 하고 나면 프로젝트 리덱터리에 다음과 같은 파일이 생성된다.

<img src="./images/21_04.png" />

이제 Prettier 설정을 하자. 먼저 Blog-backend 디렉터리에 아래와 같은 파일(**.prettierrc**)을 만든다.

```jsx
{
  "singleQuote": true,
  "semi": true,
  "useTabs": false,
  "tabWidth": 2,
  "trailingComma": "all",
  "printWidth": 80
}
```

다음으로 Prettier에서 관리하는 코드 스타일은 ESLint에서 관리하지 않도록 eslint-config-prettier를 설치하여 적용해 준다.

`$ yarn add aslant-config-prettier`

설치 후 다음 설정 파일을 만들면 된다.

```jsx
{
  "env": {
    "node": true,
    "commonjs": true,
    "es6": true
  },
  "extends": ["eslint:recommended", "prettier"],
  "globals": {
    "Atomics": "readonly",
    "SharedArrayBuffer": "readonly"
  },
  "parserOptions": {
    "ecmaVersion": 2018
  },
  "rules": {}
}
```

## 21.3 Koa 기본 사용법

#### 21.3.1 서버 띄우기

먼저 서버를 여는 방법부터 알아보자. index.js 파일에 다음 코드를 입력해 준다.

```jsx
const Koa = require('koa');

const app = new Koa();

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('Listening to port 4000');
});
```

서버를 포트 4000번으로 열고, 서버에 접속하면 'hello world'라는 텍스트를 반환하도록 설정했다.

서버를 한번 실행 해보면 아래와 같이 나오는 것을 확인할 수 있다.

<img src="./images/21_05.png" />

원래 node를 통해 자바스크립트 파일을 실행할 때는 `$ node src/index.js` 와 같이 전체 경로를 입력하는 것이 맞지만, index.js 파일은 예외로 디렉터리까지만 입력해도 실행할 수 있다. 쉽게 말해 Index.js파일은 해당 디렉터리를 대표하는 파일이라고 생각하면 된다.

이제 웹 브라우저로 http://localhost:4000/에 접속해 보면 아래와 같이 정상적으로 hello world가 출력되는 것을 확인할 수 있다.

<img src="./images/21_06.png" />

#### 21.3.2 미들웨어

Koa 애플리케이션은 미들웨어의 배열로 구성되어 있는데 조금 전 코드에서 app.use 함수를 사용했다. 이 함수는 미들웨어 함수를 애플리케이션에 등록한다.

미들웨어 함수는 다음과 같은 구조로 이루어져 있다.

```jsx
(ctx,next) => {
  
}
```

Koa의 미들웨어 함수는 두 개의 파라미터를 받는다. 첫 번째 파라미터는 조금 전에도 사용한 ctx라는 값이고, 두 번째 파라미터는 next라는 값이다.

ctx는 Context의 줄임말로 웹 요청과 응답에 관한 정보를 지니고 있다. next는 현재 처리중인 미들웨어의 다음 미들웨어를 호출하는 함수다. 미들웨어를 등록하고 next함수를 호출하지 않으면, 그다음 미들웨어를 처리하지 않는다.

만약 미들웨어에서 next를 사용하지 않으면 ctx => {}와 같은 형태로 파라미터에 next를 설정하지 않아도 괜찮다. 주로 다음 미들웨어를 처리할 필요가 없는 라우트 미들웨어를 나중에 설정할 때 이러한 구조로 next를 생략하여 미들웨어를 작성한다.

미들웨어는 app.use를 사용하여 등록되는 순서대로 처리된다. 다음과 같이 현재 요청을 받은 주소와 우리가 정해 준 숫자를 기록하는 두 개의 미들웨어를 작성해 보자.

```jsx
const Koa = require('koa');

const app = new Koa();

app.use((ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  next();
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('Listening to port 4000');
});
```

실행 중인 서버를 종료하고 다시 실행하게 되면 터미널에 아래와 같은 결과가 나타나는 것을 확인할 수 있다.

<img src="./images/21_07.png" />

크롬 브라우저는 사용자가 웹 페이지에 들어가면 해당 사이트의 아이콘 파일인 /favicon.ico 파일을 서버에 요청하기 때문에 결과에  / 경로도 나타나고 /favicon.ico 경로도 나타나게 된다.

이번에는 첫 번째 미들웨어에서 호출하던 next()를 주석으로 처리하면 어떤 결과가 나오는지 알아보자.

```jsx
const Koa = require('koa');

const app = new Koa();

app.use((ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  // next();
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('Listening to port 4000');
});
```

위와 같이 첫 번째 미들웨어를 실행한 다음 next를 호출하지 않았으니 그 아래에 있는 미들웨어들은 모두 무시 되었다.

<img src="./images/21_08.png" /> 

이러한 속성을 사용해서 조건부로 다음 미들웨어 처리를 무시하게 만들 수 있다. 아래 코드는 authorized=1이라는 쿼리 파라미터가 포함되어 있으면 이후 미들웨어를 처리해 주고, 그렇지 않으면 이후 미들웨어를 처리하지 않는 코드다.

```jsx
const Koa = require('koa');

const app = new Koa();

app.use((ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  if (ctx.query.authorized !== '1') {
    ctx.status = 401; // Unauthorized
    return;
  }
  next();
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('Listening to port 4000');
});
```

쿼리 파라미터는 문자열이기에 비교할 때는 꼭 문자열 형태로 비교해야 한다. 서버를 재시작한 뒤 아래 링크에 들어가면 다음과 같은 결과가 나타나게 된다.

- http://localhost:4000/
- http://localhost:4000/?authorized=1

<img src="./images/21_09.png" />

<img src="./images/21_10.png" />

지금은 단순히 주소의 쿼리 파라미터를 사용하여 조건부로 처리했지만, 나중에는 웹 요청의 쿠키 혹은 헤더를 통해 처리할 수도 있다.

**21.3.2.1 next 함수는 Promise를 반환**

**next 함수를 호출하면 Promise를 반환한다**. 이는 Koa가 Express와 차별화되는 부분이다.

Next 함수가 반환하는 Promise는 다음에 처리해야 할 미들웨어가 끝나야 완료된다. 다음과 같이 next 함수 호출 이후에 then을 사용하여 Promise가 끝난 다음 콘솔에 END를 기록하도록 수정해보자.

```jsx
const Koa = require('koa');

const app = new Koa();

app.use((ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  if (ctx.query.authorized !== '1') {
    ctx.status = 401; // Unauthorized
    return;
  }
  next().then(() => {
    console.log('END');
  });
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('Listening to port 4000');
});
```

저장한 후 서버를 재시작하고 http://localhost:4000/?authorized=1 주소로 들어가 보면 아래와 같이 첫 번째 미들웨어 다음에 처리해야 미들웨어 (console.log(2))가 끝난 뒤에 Promise를 반환하고 그런 다음 END를 출력하는 것을 확인할 수 있다.

<img src="./images/21_11.png" />

**20.3.2.2 async/await 사용**

Koa는 async/await를 정식으로 지원하기 때문에 해당 문법을 아주 편안하게 사용할 수 있다. 기존 코드를 async/await를 사용하는 형태로 한번 수정해보자.

> SSR을 할 때 사용하던 Express도 async/await 문법을 사요할 수 있지만, 오류를 처리하는 부분이 제대로 작동하지 않을 수 있다. 백엔드 개발을 하면서 예상치 못한 에러를 제대로 잡아내려면 express-async-errors라는 라이브러리를 따로 사용해야 한다.

```jsx
const Koa = require('koa');

const app = new Koa();

app.use(async (ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  if (ctx.query.authorized !== '1') {
    ctx.status = 401; // Unauthorized
    return;
  }
  await next();
  console.log('END');
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('Listening to port 4000');
});
```

서버를 재시작한 뒤  http://localhost:4000/?authorized=1 주소로 들어가보면 이전과 똑같이 작동하는 것을 확인할 수 있다.

