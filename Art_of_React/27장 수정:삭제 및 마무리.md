# 27장 수정/삭제 기능 구현 및 마무리

포스트를 수정하고 삭제하는 기능은 다음과 같은 흐름으로 진행된다.

> 포스트 수정 기능 구현 → 포스트 삭제 기능 구현 → react-helmet-async로 meta 태그 설정 → 프로젝트 마무리



## 27.1 포스트 수정

#### 27.1.1 PostActionButtons 컴포넌트

포스트 수정/삭제를 하려면 포스트를 읽는 화면에서 포스트 작성자에게만 포스트 상간에 수정 버튼과 삭제 버튼이 나타나도록 해야한다. 이번에는 기존에 재사용했던 Button 컴포넌트와 스타일이 다르기 때문에 재사용하지 않고 새로운 컴포넌트를 만들어 줘야 한다.

```jsx
import React from 'react';
import styled from 'styled-components';
import palette from '../../lib/styles/palette';

const PostActionButtonBlock = styled.div`
  display: flex;
  justify-content: flex-end;
  margin-top: -1.5rem;
  margin-bottom: 2rem;
`;

const ActionButton = styled.button`
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  color: ${palette.gray[6]};
  font-weight: bold;
  border: none;
  outline: none;
  font-size: 0.875rem;
  cursor: pointer;
  &:hover {
    background: ${palette.gray[1]};
    color: ${palette.cyan[7]};
  }
  & + & {
    margin-left: 0.25rem;
  }
`;

const PostActionButtons = () => {
  return (
    <PostActionButtonBlock>
      <ActionButton>수정</ActionButton>
      <ActionButton>삭제</ActionButton>
    </PostActionButtonBlock>
  );
};

export default PostActionButtons;
```

이제 PostActionButtons 컴포넌트를 PostViewer의 PostHead 하단에서 보여주어야 한다. 그런데 이 컴포넌트를 PostViewer에 직접 렌더링하면, 나중에 PostActionButtons에 onEdit, onRemove 등의 props를 전달할 때 무조건 PostViewer를 거쳐서 전달해야 한다. 정작 PostViewer 내부에서는 사용하지 않지만 내부의 컴포넌트에서 필요하기 때문에 한 번 거쳐 전달하는 것은 불편할 수 있다.

```jsx
// PostViewerContainer에서 렌더링할 때:
<PostViewer (...) onEdit={onEdit} onRemove={onRemove} />
// PostViewer에서 렌더링할 때:
<PostViewer onEdit={onEdit} onRemove={onRemove} />
```



이 방법이 틀린 것은 아니지만, 자칫하면 컴포넌트가 받아 오는 props가 너무 많아져서 관리하기 어려워질 수 있다.

이렇게 컴포넌트를 거쳐서 props를 전달하는 것이 싫다면 두 가지 방법을 고려할 수 있다.

1. PostActionButtons의 컨테이너 컴포넌트를 만들고 PostViewer 내부에서 바로 렌더링 하는 방법
2. props를 JSX 형태로 받아와서 렌더링 하는 방법

두 번째 방법의 경우 아래와 같은 형태로 구현할 수 있다.

```jsx
<PostViewer
	post={post}
	loading={loading}
	error={error}
	actionButtons={<PostActionButtons onEdit={onEdit} onRemove={onRemove} />}
```

여기서는 두 번째 방법으로 구현하도록 해보자. 왜냐하면 두 번째 방법은 굳이 컨테이너 컴포넌트를 만들지 않고 기존 PostViewerContainer 컴포넌트에서 필요한 로직을 작성하면 되기 때문이다.

먼저 PostViewer에서 받는 props와 해당 props를 사용하는 코드를 아래와 같이 추가해주고

```jsx
(...)
 
const PostViewer = ({ post, error, loading, actionButtons}) => {
  // 에러 발생 시
  if (error) {
    if (error.response && error.response.status === 404) {
      return <PostViewerBlock>존재하지 않는 포스트입니다.</PostViewerBlock>;
    }
    return <PostViewerBlock>Error Occurred!</PostViewerBlock>;
  }

  //로딩 중이거나 아직 포스트 데이터가 없을 때
  if (loading || !post) {
    return null;
  }

  const { title, body, user, publishedDate, tags } = post;
  return (
    <PostViewerBlock>
      <PostHead>
        <h1>{title}</h1>
        <SubInfo
          username={user.username}
          publishedDate={publishedDate}
          hasMarginTop
        />
        <Tags tags={tags} />
      </PostHead>
      {actionButtons}
      <PostContent dangerouslySetInnerHTML={{ __html: body }} />
    </PostViewerBlock>
  );
};

export default PostViewer;
```

그런 다음 PostViewerContainer에서 PostActionButtons를 불러온 후 PostViewer의 actionButtons props를 통해 렌더링해 준다.

```jsx
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { withRouter } from 'react-router-dom';
import PostViewer from '../../components/post/PostViewer';
import { readPost, unloadPost } from '../../modules/post';
import PostActionButtons from '../../components/post/PostActionButtons';

const PostViewerContainer = ({ match }) => {
  // 처음 마운트될 때 포스트 읽기 API 요청
  const { postId } = match.params;
  const dispatch = useDispatch();
  const { post, error, loading } = useSelector(({ post, loading }) => ({
    post: post.post,
    error: post.error,
    loading: loading['post/READ_POST'],
  }));

  useEffect(() => {
    dispatch(readPost(postId));
    //언마운트될 때 리덕스에서 포스트 데이터 없애기
    return () => {
      dispatch(unloadPost());
    };
  }, [dispatch, postId]);

  return (
    <PostViewer
      post={post}
      loading={loading}
      error={error}
      actionButtons={<PostActionButtons />}
    />
  );
};

export default withRouter(PostViewerContainer);
```

저장한 후 포스트 페이지를 열어 보면 아래와 같이 수정/삭제 버튼이 나타난 것을 확인할 수 있다.

<img src="./images/27_01.png" />

하지만 아래 보이는 이미지처럼 지금은 로그인된 사용자가 아닌 다른 사용자의 포스트를 볼 때도 이 버튼이 나타날것이다. 이 부분은 조건에 따라 버튼을 숨기는 로직으로 처리해 줄 수 있다.

<img src="./images/27_02.png" />

#### 27.1.2 수정 버튼 클릭 시 글쓰기 페이지로 이동

