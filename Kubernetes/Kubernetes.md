# Kubernetes aka k8s

### 1. Virtualization

- 컴퓨터 리소스(CPU, MEM, Storage, Network 등)의 추상화
  - 넓은 의미
- 단일 컴퓨터의 리소스를 가상 머신(VM)이라고 하는 다수의 가상 컴퓨터로 분할하는 것
  - 좁은 의미
- 장점
  - 리소스 효율성: 새로운 서비스를 위해 서버를 구매하지 않아도 된다. → VM을 위한 컴퓨터는 필요
  - 관리 편의성: Infrastructure as Code(Iac), 자동화
  - 가동 중단 시간 최소화: VM을 여러개 두어, High Availability를 구성 → 망가지면 버린다.
  - 프로비저닝 고속화: 더 많은 컴퓨팅 리소스가 필요하면, VM을 더 만든다.



### 2. VM vs Container

- VM은 각각의 OS가 존재(Type1, Type2)
- Container는 동일한 OS Kernel을 공유하며, 프로세스 수준에서 격리



### 3. Container

- 장점
  - 어플리케이션과 구동 환경(파일 시스템, 환경 변수)만을 가상화 → 프로세스
    - 부팅 시간이 따로 없고, fork()만으로 가상화 구현
    - 이미지가 가볍고, 실행이 빠르다.
- 단점
  - Kernel Panic 발생 시, 모든 컨테이너가 죽음
    - 여러 대의 VM을 두어 극복
    - VM 위에 Container 띄우기로 극복
- 앱이 구동되는 환경까지 감싸서 실행할 수 있도록 하는 격리 기술
- 컨테이너 == (마치 가상머신처럼 작동하는 틀별한) 프로세스
  - 격리된 환경 / 제한된 리소스에서 실행되는 프로세스
    - vm 생성 없이 동일한 호스트에 독립된 프로세스가 뜨는 것



### 4. Container Runtime(ex: Docker)

- 컨테이너를 만들고(Build) 실행(Run)하는 도구



### 5. Container orchestration

- Docker가 있는데 왜 Container orchestration가 필요한가?
  - 대용량 서비스 관점에서 생각해야함
  - 100대 이상의 VM, 10,000개 이상의 Container
- 배포
  - docker stop && docker run
- 모니터링
  - 별도의 Health Check Process - 서비스가 죽었을 시 이를 감지하고 다시 서비스를 제공
  - docker rm - f && docker run
- 서비스 검색 & 노출
  - LoadBalancer
  - Service Gateway
- 네트워크



### 6. 개발 트렌드의 변화

- MSA의 등장 → 애플리케이션이 작은 단위로 쪼개짐
- 기존 애플리케이션의 문제점
  - 하나의 큰 프로젝트라 서비스 변경이 어려움
  - 서비스 변경시 장애 영향도 파악이 어려움
  - 테스트 및 배포도 오래걸림
  - 한개의 프로엠워크 / 언어에 종속 됨
  - 일부 컴포넌트만 Scale Out하기 어려움



### 7. 쿠버네티스

- 컴퓨터 클러스터 기반에서 애플리케이션 컨테이너의 위치(스케줄링: 어떤 컴퓨터를 뜨게 할 것이냐)와 실행을 자동화 해준다.
- 마스터
  - 클러스터 내 모든 활동을 조율하고 관리
  - k8s 리소스들을 생성하고 관리하는 k8s API 서버 및 여러 운영 컴포넌트가 올라와 있음
  - 역할
    - 애플리케이션 스케줄링
    - 항상성 유지
- 노드
  - 실제 사용자 애플리케이션이 수행되는 VM(or 물리장비)
  - 모든 노드에 Kubelet 이라는 에이전트가 떠 있고, 이 Kubelet을 통해 마스터와 통신
- 애플리케이션 배포 == “마스터에 애플리케이션 컨테이너를 구동하라고 지시하는 것”
- 파드(Pod)
  - 하나 또는 여러 개 애플리케이션 컨테이너의 그룹을 나타내는 k8s의 추상적인 개념
  - 쿠버네티스에서 생성/관리/배포 가능한 가장 작은 컴퓨팅 단위 === “애플리케이션 그 자체”
  - 파드 단위로 애플리케이션이 격리
  - Ex
    - 80포트 사용 → 같은 파드 내에 여러 애플리케이션이 존재한다면 80포트는 하나의 애플리케이션만 사용 가능
    - 다른 파드의 경우 80포트 사용 가능
- Deployment
  - Pod를 찍어내는 Template - 어떤 앱인지 / 몇개를 띄울 것인지 / HC 어떻게 할지 / 업데이트 방법 등
  - 애플리케이션 인스턴스(Pod)를 생성하고 업데이트 하는 역할 담당
  - ReplicaSet - 항상 “지정한 파드 개수"만큼 실행될 수 있도록 관리해주는 역할
    - ReplicaSet을 5로 설정한 다음 하나의 파드가 종료되어 4개가 됐다고 가정하면, Pod를 하나 추가로 생성하여 5개의 Pod로 유지를 시켜준다.
- Service
  - 4가지 타입이 존재
    - Cluster IP(default)
    - NodePort
    - LoadBalancer
    - ExternamName
  - Pod는 언제든지 죽을 수 있는 존재 → pod IP를 그대로 사용하기 어려움
  - 이러한 짧은 생명 주기의 pod IP를 사용하지 않고, 고정된 단일 엔드포인트를 제공하자 → Service
  - 여러 개의 pod를 하나의 엔드포인드로 접근할 수 있게끔 해주는 것이 Service
  - ex: label이 붙은 pod를 하나의 접근할 수 있게끔 만들기
- 인그레스 (Ingress)
  - 인그레스는 클러스터 내부 서비스에 대한 외부 접근을 관리하는 오브젝트
  - L7 Proxy를 쿠버네티스 네이티브한 리소스로 관리할 수 있게 하자 → Ingress
    - 다양한 라우팅 룰 설정 가능
    - SSL 인증서 적용
    - Rate Limit
  - 반드시 “인그레스 컨트롤러"도 같이 배포해 주어야 동작함 (ex. ingress nginx controller)
- LoadBalancer
  - 인그레스 노드 앞에 존재하는 Service로 인그레스 노드 상태에 따라 로드밸런싱해서 전달
  - 보통 여러 개의 인그레스 노드 앞에서 인그레스 노드의 중단에 관계없이 서비스를 제공하기 위해 사용



### 8. 쿠버네티스 설치

[운영 수준의 컨테이너 오케스트레이션](https://kubernetes.io/ko/)

1. 쿠버네티스를 학습하고 설치하고 많은 소요가 생긴다
2. 이를 해결하기 위해 쿠버네티스를 서비스로 이용하자
3. Kubernetes As A Service - DKOS 등