# 2022/08/11

### 1. 브라우저가 화면을 렌더링 하는 동작에 대해서 설명해보세요.

- HTML 파일을 파싱 후 DOM 트리 구축
- CSS 파일을 파싱 후 CSSOM 트리 구축
- Javascript 파일 (script 태그)를 만나면 Javascript를 실행 -> 다만 HTML 파일 중간에 script 태그가 있는 경우는 HTML 파싱을 중단하고 Javascript를 실행
- DOM 트리와 CSSOM 트리를 조합해서 Render 트리 구축 - Reflow
- Viewport를 기준으로 각 노드가 가지고 있는 위치를 설정 - Layout
- 위 과정에서 계산된 위치를 바탕으로 화면을 그린다. - Paint



### 2. CSR과 SSR의 차이와 각각의 장단점에 대해서 설명해보세요

**CSR**

한 번의 요청을 통해 HTML, CSS, Javascript 파일을 받아오고 사용자와의 상호작용에 따라  Javascript를 통해 동적으로 화면을 렌더링한다.

장점

- 서버에 단 한 번 요청을 하기 때문에 서버의 부하가 줄어들다.
- 사용자와의 상호 작용을 통해 동적으로 빠르게 화면을 렌더링 시키기 때문에 사용자 경험이 좋다.



단점

- 파일 크기가 커지게 되면 초기 로딩 시간이 길어질 수 있고 이는 곧 사용자 경험의 저하로 이어질 수 있다.
- 크롬을 제외한 다른 브라우저에서는 Javascript를 지원하지 않기 때문에 검색 엔진 봇이 크롤 하는 데에 문제가 있고 이로 인해 검색 엔진 최적화(SEO)에 어려움이 있다.



**SSR**

각각의 페이지 별로 서버에 요청을 해서 HTML, CSS, Javascript 파일을 받아와 화면을 렌더링한다.

장점

-  초기 로딩 속도가 빠르다
- JS를 통해 동적으로 화면을 렌더링 하는 것이 아니기 때문에 검색 엔진 최적화에 용이하다.

단점

- 페이지를 요청할 때마다 새로고침을 하기 때문에 사용자 경험이 좋지 않을 수 있다.
- 서버에 많은 요청을 하기 때문에 서버에 부담이 크다.



### 3. www.google.com 을 주소창에 입력했을 때 발생하는 동작을 설명해보세요.

- URL을 웹 브라우저의 주소창에 입력한다.
- 웹 브라우저가 URL을 해석하고, 문법에 맞지 않으면 기본 검색엔진으로 검색한다.
- 문법에 맞으면 URL의 호스트 부분을 인코딩한다.
- HSTS(HTTP Strict Transport Security) 목록을 확인하고 있으면 HTTPS로, 없으면 HTTP로 요청한다.
- DNS(Domain Name Server) 조회
  - 브라우저/로컬 캐시 확인해서 도메인에 해당하는 IP가 있는지 확인한다.
  - 없으면 OS에게 DNS 서버에 요청하라고 지시한다.
  - DNS 서버는 해당 도메인에 해당하는 IP를 돌려준다.
- TCP 소켓을 열고 3-way handshake로 연결을 설정한다.
- HTTPS 요청이라면 TLS(Transport Layer Security) handshake 과정을 통해 세션키를 생성한다.
- 세션이 유지되는 동안 서버에게 요청하고 응답을 받는 과정을 반복한다.
  - 응답 상태코드에 따라 다르게 처리한다.
  - 응답을 디코딩(Decoding)하고 캐싱 가능하다면 캐싱한다.
- 웹브라우저는 응답받은 HTML/CSS/JS 및 이미지,폰트 등의 리소스를 사용하여 렌더링 한다.
- 서버와의 세션이 종료되면 4-way handshake로 연결을 종료한다.

 

### 4. CSS 속성 중에 visibility: hidden과 display: none의 차이점을 설명해보세요.

`visibility:hidden` - 해당 엘리먼트를 렌더링을 하고 난 후 화면에서 보이지 않게 만드는 것. 단, width와 height를 설정한 경우 공간은 차지한다.

`display: none` - 해당 엘리먼트를 애초에 렌더링 하지 않는 속성. 어떠한 공간도 차지하지 않는다.



### 5. 마진 겹침 현상에 대해서 설명해보세요.

마진 겹침 현상은 블록 레벨 엘리먼트에 한해서 발생하는 현상으로 좌우 방향이 아닌 오로지 수직 방향으로 적용된다.

2개의 마진이 겹칠 때 더 큰 마진으로 덮어 씌우는 방식이며 마진이 음수인 경우 더하는 방식을 취한다.

#### **마진겹침이 발생하는 경우**

1. 인접한 엘리먼트
2. 부모와 처음/마지막 자식 사이
   - 부모의 마진과 처음 또는 마지막 자식의 마진이 같은 경우 완전히 겹쳐서 나타나게 되는데 이를 해결하기 위해서는 **부모에 inline 컨텐츠, border, padding** 을 줘서 경계를 구분시키면 된다.
3. 빈 엘리먼트
   - 높이가 없는 빈 엘리먼트가 인접했을 때도 마진 겹침 현상이 발생한다. 이를 해결하기 위해서는 **빈 엘리먼트에 height, min-height, padding, border나 inline 컨텐츠** 를 줘서 경계를 구분시키면 된다.



### 6-1. 알고 있는 display 속성에 대해서 말해보세요.

inline , flex , block, none, inline-block, grid

### 6-2. inline과 inline-block의 차이는 무엇인가요?

**inline**

- inline 속성을 가진 태그는 가로폭을 전부 차지 하지 않고 상위 태그 옆으로 붙는 특징이 있다.

- width와 height값을 지정해도 크기는 변하지 않는다.

**block**

- block 속성을 가진 태그는 가로폭을 전부 차지하며 width, height값을 가질 수 있다.

**inline-block**

- inline-block는 이러한 inline 속성과 block속성의 특징을 모두 가지고 있는 속성
-  가로폭을 전부 차지하지 않고, width와 height 값을 가질 수 있다.



### 7. CORS에 대해서 설명해보세요.

다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 **cross-origin HTTP 요청** 에 의해 요청된다.

하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한하는데 이것을 `Same-Origin-Policy(동일 근원 정책)`이라고 한다. 다시 말해, 요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜, 호스트명, 포트가 같아야 함을 의미한다

여기서 `CORS`는 타 도메인 간에 자원을 공유할 수 있게 해주는 것이다. `Cross-Origin Resource Sharing` 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 **출처 집합**을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로써 동작한다.



**클라이언트에서 CORS 해결하기**

1. 웹 브라우저 실행 옵션이나 플러그인을 통한 동일 출처 정책 회피하기
   - 동일 출처 정책은 브라우저에서 임의로 하는 것이기 때문에 브라우저에서 동일 출처 정책을 사용하지 않으며 된다.
2. jsonp 방식으로 json 데이터 가져오기
   - 자바스크립트 파일이나 css 파일은 동일 출처 정책에 영향을 받지 않고 가져올 수 있다.
   - 이를 이용해서 자바스크립트 파일을 가져와서 이를 json 형식으로 파싱해서 데이터를 사용할 수 있다.

[참고](https://bohyeon-n.github.io/deploy/web/cors.html)



### 8. 화살표 함수와 `function` 키워드를 사용하여 선언한 함수의 차이점에 대해 설명해보세요.

1. 기존의 함수보다 간략하게 함수를 표현할 수 있다.

2. 화살표 함수는 인스턴스를 생성할 수 없는 `non-constructor`이다.

   ```javascript
   const Foo = () => {};
   // 화살표 함수는 생성자 함수로 호출할 수 없다.
   new Foo(); // TypeError: Foo is not a constructor
   ```

3. 화살표 함수는 함수 자체의 `this`를 바인딩하지 않는다.

   - 화살표 함수 내부에서 `this` 에 접근하게 되면 `this` 가 가리키는 곳은 화살표 함수를 선언한 스코프(상위 스코프)의 `this`를 참조하게 된다.



### 9. 자바스크립트 엔진이 비동기를 처리하는 과정에 대해서 설명해보세요

#### 1. 비동기 처리를 이해하기 위해 알아야 하는 용어

**1) 논 블로킹**

자바스크립트 엔진은 기본적으로 싱글 쓰레드로 동작하기 때문에 비동기 동작의 경우 **Webapi(브라우저)**에게 비동기 동작(ex: http 요청)을 위임함으로써 다른 동작을 실행할 수 있다.

**2) 콜 스택**

자바스크립트가 코드를 실행할 때 생성하는 실행 컨텍스트를 저장하는 자료구조

1. 자바스크립트 엔진은 함수를 호출하면 이를 콜 스택에 추가한 후 함수를 실행한다.
2. 함수에 의해 호출 되는 모든 함수(내부 함수)는 콜 스택에 추가되고 해당 위치에서 실행된다.
3. 함수의 실행이 종료되면 콜스택에서 제거한 후 중단된 시점부터 다시 실행한다.
4. 스택으로 할당된 공간보다 많은 공간을 차지하면 stack overflow가 발생한다.

**3) 태스크 큐** 

태스크 큐는 `setTimeout` 이나 `setInterval`과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역

**4) 이벤트 루프**

이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다.

***만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.***



#### 2. 자바스크립트 엔진이 비동기를 처리하는 방식

1. 코드를 실행한 후 자바스크립트 엔진이 비동기 작업을 만나게 되면 비동기 작업은 Webapi에 위임(태스크 큐에 push)되어 대기하게 된다.
2. 만약 콜 스택이 비어 있는 것을 이벤트 루프가 확인을 하게 되면, 다시 말해 전역 코드 및 명시적으로 호출된 함수가 모두 종료하면 
   이벤트 루프가 태스크 큐에 존재하는 콜백 함수를 콜 스택에 넘겨주고 콜 스택에 존재하는 콜백 함수를 실행한 후 콜 스택에서 제거한다.