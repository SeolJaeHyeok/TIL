# 2020.03.05

## 3.1 클래스형 컴포넌트

- 2장에서 본 App 컴포넌트는 함수형 컴포넌트이면 아래와 같은 구조로 이루어져있다.

```react
import React from "react";
import "./App.css";

function App() {
  const name = "리액트";
  return <div className="react">{name}</div>;
}

export default App;
```

- 컴포넌트를 선언하는 방식은 두 가지다. 하나는 위와 같은 함수형 컴포넌트로 선언하는 것 또 다른 하나는 아래와 같이 클래스형 컴포넌트로 선언하는 것이다. 

```react
import React from "react";

class App extend Component {
  render() {
		const name = "리액트";
    return <div className="react">{name}</div>
  }
}

export default App;
```

- 클래스형 컴포넌트로 바뀌었지만 역할은 함수형 컴포넌트와 똑같다. 차이점은 클래스형 컴포넌트는 <b>state 기능 및 라이프사이클 기능을 사용할 수 있다는 것과 임의 메서드를 정의할 수 있다는 것 </b>이다

> 💬
>
> ES6 이전에 자바스크립트에는 class가 없었다. 개념은 있었지만 그것을 구현하려면 class 대신 prototype이라는 문법을 사용하여 아래와 같이 작업해야 했다.
>
> ```javascript
> function Dog(name) {
>   this.name = name;
> }
> 
> Dog.prototype.say = function() {
>   console.log(this.name + ": 멍멍");
> }
> var dog = new Dog('검둥이');
> dog.say(); // 검둥이: 멍멍
> ```

>💬
>
>ES6 문법부터는 위와 기능이 똑같은 코드를 class를 사용하여 아래와 같이 작성할  수 있다.
>
>```javascript
>Class Dog() {
>	constructor(name) {
>		this.name = name;
>  }
>  
>  say() {
>    console.log(this.name + ": 멍멍");
>  }
>}
>
>const dog = new Dog("흰둥이");
>dog.say(); // 흰둥이: 멍멍
>```

- 클래스형 컴포넌트에서는 <b>render 함수가 꼭 있어야 하고</b>, 그 안에서 보여 주어야 할 JSX를 반환해야 한다.

- 그렇다면 컴포넌트를 선언할 수 있는 두 가지 방법 중 어느 상황에서 함수형 컴포넌트를 사용해야할까?

> 함수형 컴포넌트의 장점을 나열해보면 다음과 같다.
>
> 1. 클래스형 컴포넌트보다 선언하기가 훨씬 편하다.
> 2. 메모리 자원도 클래스형 컴포넌트보다 덜 사용한다.
> 3. 프로젝트를 완성하여 빌드한 후 배포할 때도 함수형 컴포넌트를 사용하는 것이 결과물의 파일 크기가 더 작다. (사실상 별 차이가 없긴 하다.)
>
> 단점으로는 state와 라이프사이클 API의 사용이 불가능하다는 점이었는데 리액트 16.8 업데이트 이후 Hooks라는 기능이 도입되면서 해결됐다. 완전히 클래스형 컴포넌트와 똑같이 사용할 수 있는 것은 아니지만 조금 다른 방식으로 비슷한 작업을 할 수 있게 됐다.
>
> ❗️리액트 공식 메뉴얼에서도 컴포넌트를 새로 작성할 때 함수형 컴포넌트와 Hooks를 사용하도록 권장하고 있다. 하지만 클래스형 컴포넌트의 기능은 꼭 알아두어야 한다.

## 3.2 컴포넌트 생성

Src 디렉토리에 MyComponent.js 파일을 만들고 아래와 같이 작성해준다.

```react
import React from "react";

const MyComponent = () => {
  return <div>새로운 컴포넌트</div>
}

export default MyComponent;
```

여기서 함수를 작성할 때 function 컴포넌트를 사용하지 않고 () => {}를 사용하여 함수를 만들어 줬다. 이는 ES6에 도입된 화살표 함수 문법이다. 자세히 살펴보면

> 화살표 함수(Arrow Function)는 ES6 문법에서 함수를 표현하는 새로운 방식이다. 그렇다고 해서 기존 function을 이용한 함수 선언 방식을 아예 대체하지는 않는다. 이 함수는 주로 함수를 파라미터로 전달할 때 유용하게 쓰인다.
>
> ```javascript
> setTimeout(function() {
>   console.log("hello world");
> }, 1000);
> 
> setTimeout(() => {
>   console.log("hello world");
> }, 1000);
> ```
>
> 이 문법이 기존 function을 대체할 수 없는 것은 용도가 다르기 때문인데 무엇보다 서로 가리키고 있는 this 값이 다르다.
>
> ``` javascript
> function BlackDog(){
>   this.name = "흰둥이";
>  	return {
>     name: "검둥이",
>     bark: function(){
>       console.log(this.name + ": 멍멍");
>     }
>   };
> }
> 
> const blackDog = new BlackDog();
> blackDog.bark(); // 검둥이: 멍멍
> 
> function WhiteDog(){
>   this.name = "흰둥이";
>  	return {
>     name: "검둥이",
>     bark: () => {
>       console.log(this.name + ": 멍멍");
>     }
>   };
> }
> 
> const whiteDog = new WhiteDog();
> whiteDog.bark(); // 흰둥이: 멍멍
> ```
>
> Function()을 사용했을 때는 검둥이가 나타나고, () => {}를 사용했을 때는 흰둥이가 나타난다. 일반 함수는 자신이 종속된 <b>객체를 this로 가리키며</b>, 화살표 함수는 <b>자신이 종속된 인스턴스를 가리킨다.</b>
>
> 화살표 함수는 값을 연산하여 바로 반환해야 할 때 사용하면 가독성을 높일 수 있다.
>
> ```javascript
> function twice(value) {
> 	return value * 2;
> }
> 
> const triple = (value) => value * 3;
> ```
>
> 이렇게 따로 {}를 열어 주지 않으면 연산한 값을 그대로 반환한다는 의미다.

- function 키워드를 사용하는 것과 화살표 함수를 사용하는 것에는 큰 차이가 없다. 어떤 방식을 선택할지는 취향에 따라 달라진다.

- MyComponent.js 파일의 맨 아래 코드를 보면 아래와 같은 코드가 있다.

  ```react
  export default MyComponent;
  ```

  이 코드는 다른 파일에서 이 파일을 import할 때, 위에서 선언한 MyComponent 클래스를 불러오도록 설정하는 코드다.

- App 컴포넌트에서 MyComponent 컴포넌트를 불러와서 사용을 해보면

```react
import React from "react";
import MyComponent from "./MyComponent";

const App = () => {
  return 
  	<>
  		<MyComponent />
  	</>
}

export default App;
```

위와 같이 내가 만든 컴포넌트를 import해서 사용할 수 있게 된다. 결과를 확인해보면 MyComponent에서 작성한 내용이 화면에 나타나게 된다.