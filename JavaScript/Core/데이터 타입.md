# Data

### `자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써 기본형과 참조형이 다르게 동작하는 이유를 이해하고 활용할 수 있도록 하는 것을 목표`

#### 1. 데이터 타입의 종류

데이터 타입은 크게 기본형(primitive type)과 참조형(reference type)이 있다. 

기본형에는 number, string, boolean, null, undefined 등이 있으며 ES6에 symbol이 추가되었다. 

참조형은 Object, Array, Function, Date, RegExp 등이 있고 ES6에 추가된 Map, WeakMap, Set, WeakSet 등이 객체의 하위 분류에 속한다.

#### *그렇다면 어떤 기준으로 기본형과 참조형을 구분하는 걸까?*

일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다고 알려져 있다. 사실 둘 모두 복제를 하긴 하지만 ***기본형은 값이 담긴 주솟값을 바로 복제하는 반면 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다는 점이다.***

기본형은 불변성(immutablilty)을 띈다. 불변성을 잘 이해하려면 메모리와 데이터에 대한 지식과 나아가 식별자와 변수의 개념을 구분할 수 있어야 한다.

#### 2. 데이터 타입에 관한 배경지식

**2-1 메모리와 데이터**

0 또는 1로 표현할 수 있는 하나의 메모리 조각을 비트(bit)라고 한다. 각 비트는 고유한 식별자(unique identifier)를 통해 위치를 확인할 수 있는데 0과 1만 표현할 수 있는 비트 단위로 위치를 확인하는 것은 매우 비효율적이다. 대신 ***몇 개씩 묶어 하나의 단위로 여긴다면 표현할 수 있는 값도 늘어나며 검색 시간도 줄일 수 있을 것이다.***

매우 많은 비트를 한 단위로 묶으면 검색 시간을 줄이고 표현할 수 있는 데이터의 개수도 늘어나지만 동시에 낭비되는 비트가 생기기도 한다. 따라서 표현 가능한 개수의 어느 정도 제약이 생기더라도 문제되지 않을 정도의 공간을 묶는 편이 낫다. 이 결과 *바이트(byte)* 가 생겼다. 

1바이트는 8개의 비트로 구성되어 있으며 1바이트는 총 256(2^8)개의 값을 표현할 수 있다. C/C++, 자바 등의 정적 타입 언어는 메모리의 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 2바이트, 4바이트 등으로 나누어 놨다. 예를 들어 2바이트 크기의 정수형 타(short)는 0을 포함해 -32768~ +32768까지의 숫자만 허용된다. 그 이상 또는 이하의 숫자를 입력할 경우 오류가 나거나 잘못된 값이 저장된다.

메모리 용량이 부족하던 시절에는 숫자를 표현하기 위해 형변환을 해주어야 했기에 번거로운 작업이었지만 메모리의 용량이 과거보다 커진 상황에 등장한 자바스크립트는 상대적으로 메모리 관리에 대한 압박에서 자유로워졌다. 숫자의 경우 정수형인지 부동소수형인지 구분하지 않고 64bit 즉, 8byte를 확보한다.

앞서 각 비트는 고유한 식별자를 지닌다고 언급했는데 바이트 또한 시작하는 비트의 식별자로 위치를 파악할 수 있다. 모든 데이터는 바이트 단위의 식별자, 정확하게 ***메모리 주솟값을 통해 서로를 구분하고 연결***할 수 있다.

**2-2 식별자와 변수**

변수는 '변할 수 있는 수'를 뜻한다. 반드시 숫자여야 하는 것은 아니고 컴퓨터 용어에서는  **'변할 수 있는 무언가'** 로 확장되었다. 여기서 '무언가'는 **데이터**를 뜻한다. 숫자, 문자열, 객체, 배열 등 모두 데이터가 된다. **식별자**는 어떤 데이터를 식별하는 데 사용하는 이름 즉, **변수명**이다.

#### 3. 변수 선언과 데이터 할당

**3-1 변수 선언**

```javascript
var a;
```

위 코드는 기본적인 변수 선언식이다.

이를 말로 풀어보면 **"변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"**가 된다. 변할 수 있는 데이터이니 선언할 때는 undefined이더라도 나중에 다른 값으로 바꾸면 된다. 변수란 결국 **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇** 이라고 생각할 수 있다.

위 코드의 명령을 받은 컴퓨터는 메모리에서 비어있는 공간 하나를 확보한다. 이 임의의 공간을 1003번이라고 하고 이름(식별자)을 a라고 지정한다. 여기까지가 변수 선언 과정이다. 이후에 사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환할 것이다.

**3-2 데이터 할당**

```javascript
var a;						// 변수 a 선언
a = 'abc'; 				// 변수 a에 데이터 할당

var a = 'abc'; 		// 변수 선언과 할당을 한 문장으로 표현
```

위의 예제처럼 두 문장으로 나누어 명령하든 한 문장으로 명령하든, 자바스크립트 엔진은 결국 같은 동작을 수행한다. 메모리에서 비어있는 공간을 확보하고 그 공간의 이름을 설정하는 선언 과정은 앞서 살펴본 것과 같다. 할당 과정은 a라는 이름을 가진 주소를 검색해서 그곳에 문자열 'abc'를 할당하면 될 것이다.

그런데 실제로는 해당 위치에 문자열 'abc'를 직접 저장하지는 않는다. 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고, 그 주소를 변수 영역에 저장하는 식으로 이루어진다. 

|    변수영역     | **주소** | ...  |   1002   |        1003         |   1004   |   1005   | ...  |
| :-------------: | :------: | :--: | :------: | :-----------------: | :------: | :------: | :--: |
|                 |  데이터  |      |          | 이름: a,  값: @5004 |          |          |      |
| **데이터 영역** | **주소** | ...  | **5002** |      **5003**       | **5004** | **5005** | ...  |
|                 |  데이터  |      |          |                     |  'abc'   |          |      |

>1. 변수 영역에서 빈 공간(@1003)을 확보
>2. 확보한 공간의 식별자를 a로 지정
>3. 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장
>4. 변수 영역에서 a라는 식별자 검색(@1003)
>5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입

#### ***왜 변수 영역에 값을 직접 대입하지 않고 번거롭게 한 단계를 더 거치는 것일까?***

이는 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위한 고민의 결과다. 앞서 자바스크립트는 숫자형 데이터에 대해 64bit의 공간을 확보한다고 했다. 반면 문자열은 특별히 정해진 규격이 없다. 한 글자마다 영어는 1byte, 한글은 2byte 등으로 각각 필요한 메모리 용량이 가변적이며 전체 글자 수 역시 가변적이기 때문이다.

**만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해서는 '확보된 공간을 변환된 데이터의 크기에 맞게 늘리는 작업'이 선행돼야 할 것이다.** 이처럼 효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.

문자열 'abc'의 마지막에 'def'를 추가하려고 하면 컴퓨터는 앞서 'abc'가 저장된 공간에 'abcdef'를 할당하는 대신 문자열을 **새로** 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결한다. 반대로 'abc'의 마지막 'c'를 제거하라고 해도 새로 만든다. 즉, **기존 문자열에 어떤 변환을 가하든 상관 없이 무조건 새로 만들어 별도의 공간에 저장한다.**

|    변수영역     | **주소** | ...  |   1002   |        1003         |   1004   |   1005   | ...  |
| :-------------: | :------: | :--: | :------: | :-----------------: | :------: | :------: | :--: |
|                 |  데이터  |      |          | 이름: a,  값: @5005 |          |          |      |
| **데이터 영역** | **주소** | ...  | **5002** |      **5003**       | **5004** | **5005** | ...  |
|                 |  데이터  |      |          |                     |  'abc'   | 'abcdef' |      |

다른 예로 500개의 변수를 생성해 모든 변수에 숫자 5를 할당하는 상황을 생각해보자.

각 변수를 별개로 인식하려면 500개의 변수 공간을 확보하는 것은 불가피하다. 그런데 각 변수 공간마다 매번 숫자 5를 할당하려면 숫자형 데이터는 8byte가 필요하므로 총 4000(500 * 8byte)byte가 필요하게 된다. 

그 대신 5를 별도의 공간에 한 번만 저장하고 해당 주소만 입력한다면 어떨까? 예를 들어, 주소 공간의 크기가 2byte라고 한다면 1008(500*2 + 8)byte만 이용하면 된다. 이처럼 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다.

